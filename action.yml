name: Bootstrap a new account in access-control repo
description: "Sets up a new AWS account and basic roles inside the access control repo"
inputs:
  gruntwork_code_access_token:
    description: "The GitHub token to use for checking out the infrastructure-live repo"
    required: true
  manage_repo_token:
    description: "The GitHub token to use for checking out the infrastructure-live repo"
    required: true
  gruntwork_context:
    description: ""
    required: true

runs:
  using: composite
  steps:
    - name: "[Baseline]: Read account request"
      id: gruntwork_context
      uses: gruntwork-io-team/pipelines-bootstrap@main
      with:
        cache: ${{ inputs.gruntwork_context }}

    - name: "[BoilerplateAccessControl] Checkout access control repo"
      uses: actions/checkout@v4
      with:
       token: ${{  inputs.manage_repo_token }}
       repository: ${{github.repository_owner }}/pipelines-v3-access-control-test # TODO ${{ steps.gruntwork_context.outputs.access_control_repo }}
       path: pipelines-v3-access-control-test # TODO ${{ steps.gruntwork_context.outputs.access_control_repo }}
       ref: main
       fetch-depth: 0

    - name: "[BoilerplateAccessControl] Install boilerplate"
      shell: bash
      run: |
        curl -Ls https://raw.githubusercontent.com/gruntwork-io/gruntwork-installer/main/bootstrap-gruntwork-installer.sh | bash /dev/stdin --version "${{ steps.gruntwork_context.outputs.gruntwork_installer_version }}"
        gruntwork-install --binary-name boilerplate --repo https://github.com/gruntwork-io/boilerplate --tag "${{ steps.gruntwork_context.outputs.boilerplate_version }}"

    - name: "[BoilerplateAccessControl] Checkout architecture catalog"
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.gruntwork_code_access_token }}
        repository: gruntwork-io/terraform-aws-architecture-catalog
        path: terraform-aws-architecture-catalog
        ref: ${{ steps.gruntwork_context.outputs.arch_catalog_version }}

    - name: "[BoilerplateAccessControl] Run boilerplate to scaffold new account in access-control repo"
      shell: bash
      working-directory: pipelines-v3-access-control-test # TODO ${{ steps.gruntwork_context.outputs.access_control_repo }}
      env:
        TAGS: ${{ steps.bootstrap.outputs.tags }}
        WORKING_DIRECTORY: ${{ steps.bootstrap.outputs.working_directory }}
        INFRA_LIVE_DIRECTORY: ${{ steps.bootstrap.outputs.infra_live_directory }}
        ORG_NAME_PREFIX: ${{ steps.bootstrap.outputs.org_name_prefix }}
        AWS_REGION: ${{ steps.bootstrap.outputs.aws_region }}
        INFRA_LIVE_REPO_NAME: pipelines-v3-access-control-test #${{ steps.gruntwork_context.outputs.access_control_repo }}
        TOFU_VERSION: ${{ steps.bootstrap.outputs.tofu_version }}
        TERRAGRUNT_VERSION: ${{ steps.bootstrap.outputs.terragrunt_version }}
        CREATE_VPC: ${{ steps.bootstrap.outputs.create_vpc }}
        CATALOG_REPOSITORIES: ${{ steps.bootstrap.outputs.catalog_repositories }}
      run: |
        # Convert list of accounts to Bash array. We use working_directory here because GW Pipelines will configure
        # its name as a comma-separated list of account names.
        IFS=',' read -ra account_names <<<"$WORKING_DIRECTORY"

        # Convert Bash array to JSON array: https://stackoverflow.com/a/67489301/483528
        account_names_as_json_list="$(jq --compact-output --raw-output --monochrome-output --null-input '$ARGS.positional' --args -- "${account_names[@]}")"

        # Use yq to filter accounts.yml to just the accounts we created, producing JSON output
        AWS_ACCOUNTS="$(yq --no-colors -o=json -I=0 pick\("$account_names_as_json_list"\) "../$INFRA_LIVE_DIRECTORY/accounts.yml")"

        # Run boilerplate to scaffold out the access control new account
        boilerplate \
          --template-url ../terraform-aws-architecture-catalog//templates/devops-foundations-infrastructure-live-delegated \
          --output-folder . \
          --var AWSAccounts="$AWS_ACCOUNTS" \
          --var OrgNamePrefix="$ORG_NAME_PREFIX" \
          --var DefaultRegion="$AWS_REGION" \
          --var RepoBaseUrl=github.com/{{ .GithubOrg }} \
          --var GithubOrg={{ .GithubOrg }} \
          --var InfraLiveRepoName="$INFRA_LIVE_REPO_NAME" \
          --var InfraModulesRepoName="$INFRA_MODULES_REPO_NAME" \
          --var InfraModulesReleaseVersion="$INFRA_MODULES_RELEASE_VERSION" \
          --var TerraformVersion="$TOFU_VERSION" \
          --var TerragruntVersion="$TERRAGRUNT_VERSION" \
          --var DefaultTags="$TAGS" \
          --var VPCCreated="$CREATE_VPC" \
          --var CatalogRepositories="$CATALOG_REPOSITORIES" \
          --non-interactive

    - name: Create pull request
      shell: bash
      id: create_access_control_pr
      working-directory: ${{ steps.gruntwork_context.outputs.delegate_repo_name }}
      env:
        DELEGATE: ${{ steps.gruntwork_context.outputs.delegate_repo_name }}
      run: |
        PR_URL=$(gh pr create --base "main" --title "Roles for $DELEGATE" --body "This pull request sets up new roles for the $DELEGATE repository")
        PR_NUMBER=$(basename $PR_URL)
        echo "pr_number=$PR_NUMBER" >>

    - name: Merge Access Control Pull Request
      uses: juliangruber/merge-pull-request-action@v1
      with:
        github-token: ${{ inputs.manage_repo_token }}
        number: ${{ steps.create_access_control_pr.outputs.pr_number }}
        method: squash # merge rebase
        repo: $GITHUB_REPOSITORY_OWNER/pipelines-v3-access-control-test #${{ steps.gruntwork_contest.outputs.access_control_repo }}